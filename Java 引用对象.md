# 前言

参考网址：

- https://docs.oracle.com/javase/8/docs/api/java/lang/ref/package-summary.html

`java.lang.ref` 包提供了一些 reference-object classes，它们可以和 garbage collector 进行有限的交互。

# 引用类型

- `PhantomReference<T>`：虚引用（幻象引用）对象，当垃圾回收器认为和这些对象关联的引用可能被回收时，虚引用将会进入队列；
- `Reference<T>`：引用对象的抽象基类；
- `ReferenceQueue<T>`：引用队列，在检测到适当的可达性更改后，垃圾收集器将已注册的引用对象追加到其中；
- `SoftReference<T>`：软引用对象，它们由垃圾收集器根据内存需求自行清除；
- `WeakReference<T>`：弱引用对象，和它们关联的对象将会被设置为 finalizable、finalized，最后被回收；

程序可以使用引用对象来维护对其他对象的引用，以便后者仍然可以被收集器回收。程序也可以安排在收集器确定给定对象的可达性发生变化后的一段时间内得到通知。

引用对象（`reference object`）封装了对其他对象的引用，因此可以像检查其他对象一样检查和操作引用本身。

提供了三种类型的引用对象，一个比一个弱：soft、weak 和 phantom。

每种类型也对应了一种可达性等级，定义如下：

- Soft references 可以用于实现 memory-sensitive caches；
- Weak references 可以实现规范化的映射关系，这种 mapping 不会阻止对 keys 或者 values 的回收；
- Phantom references 用于调度事后清理工作；

每种引用类型都实现了 Reference 抽象基类，这些类型的实例都封装了对某个对象的单个引用实例，它被称为 `referent`。引用对象提供了方法用于获取和清理具体的引用。除了清理操作之外，引用对象是不可变的，所以不会提供 set 操作。程序可以进一步子类化这些子类，为其目的添加任何需要的字段和方法，或者可以不加更改地使用这些子类。

# 注意事项

创建引用对象时，可以将适当的引用对象注册到引用队列，从而实现当对象的可达性发生变化就进行通知的目的。

在垃圾收集器确定引用的可达性已更改为与引用类型对应的值后，它将清除引用并将其添加到关联队列中。此时，该引用被认为已进入队列。程序可以通过轮询或阻塞从队列中删除引用，直到一个引用可用为止。引用队列实现了 `ReferenceQueue` 类。

注册的引用对象和其队列是 one-sided（单方面的）。也就是说，队列不跟踪向其注册的引用。如果一个已注册的引用本身变得不可达，那么它将永远不会进入队列。只要程序对引用对象感兴趣，使用引用对象的程序就有责任确保对象保持可访问。

虽然有些程序会选择指定一个线程从一个或多个队列中删除引用对象并处理它们，但这是不必要的。

一种通常很有效的策略是在执行其他一些相当频繁的操作的过程中检查引用队列。例如，使用弱引用实现弱键的  hashtable 可以在每次访问该表时轮询其引用队列。这就是 `WeakHashMap` 类的工作原理。因为 `ReferenceQueue.poll` 方法简单地检查内部数据结构，这种检查将给哈希表访问方法增加很少的开销。

# 可达性

从强引用到弱引用，不同的可达性等级也对应着一个对象的生命周期，它们的操作定义如下：

- 如果某个线程可以在不遍历任何引用对象的情况下访问某个对象，则该对象为强可达对象。新创建的对象可以被创建它的线程强访问。
- 如果一个对象不是强可达的，但可以通过遍历软引用来到达，则该对象是软可达的。
- 如果一个对象既不是强可及的，也不是软可及的，而是可以通过遍历弱引用到达的，那么这个对象就是弱可及的。当弱可达对象的弱引用被清除时，该对象将符合终结条件。
- 如果一个对象既不是强可达的，也不是软可达的，也不是弱可达的，它已经 finalized，并且有一些虚引用引用它，那么它就是虚可达的。
- 最后，当一个对象无法以上述任何一种方式访问时，该对象是不可访问的，因此有资格进行回收。

